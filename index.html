<!DOCTYPE html>
<html>
<head>
  <title>CSV/TSV Attendance Processor</title>
</head>
<body>
  <h2>Select local CSV/TSV file:</h2>
  <input type="file" accept=".csv,.tsv,text/csv,text/tab-separated-values" id="fileInput" />
  <button onclick="downloadCsv()" id="downloadBtn" style="display:none;">Download Processed CSV</button>
  <pre id="status"></pre>

  <script>
    let processedCsv = '';
    let defaultFilename = 'AACActivityAttendance.csv';

    document.getElementById('fileInput').addEventListener('click', function() {
      this.setAttribute('nwsaveas', defaultFilename);
    });

    document.getElementById('fileInput').addEventListener('change', handleFile);

    function handleFile(event) {
      const file = event.target.files[0];
      if (!file) return;
      const statusEl = document.getElementById('status');
      statusEl.textContent = '';

      if (file.name !== defaultFilename) {
        statusEl.textContent = 'Warning: File is not named "' + defaultFilename + '".\n';
      }

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          processedCsv = processText(e.target.result);
          document.getElementById('downloadBtn').style.display = 'inline';
          statusEl.textContent += 'Processing done. Click "Download Processed CSV".';
        } catch (err) {
          statusEl.textContent += 'Error processing file: ' + err.message;
          console.error(err);
        }
      };
      reader.readAsText(file);
    }

    // Robust parser for whole CSV/TSV text.
    // Supports quoted fields with escaped quotes ("") and embedded newlines.
    function parseDelimitedText(text, delimiter) {
      const rows = [];
      const row = [];
      let field = '';
      let inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        if (ch === '"') {
          // if currently in quotes and next char is also quote -> escaped quote
          if (inQuotes && i + 1 < text.length && text[i + 1] === '"') {
            field += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === delimiter && !inQuotes) {
          row.push(field);
          field = '';
        } else if (ch === '\r') {
          // ignore CR
        } else if (ch === '\n' && !inQuotes) {
          row.push(field);
          rows.push(row.slice());
          field = '';
          row.length = 0;
        } else {
          field += ch;
        }
      }
      // push last field/row if any
      if (field !== '' || row.length > 0) {
        row.push(field);
        rows.push(row.slice());
      }
      return rows;
    }

    function detectDelimiter(headerLine) {
      // common delimiters: comma and tab. Choose tab if tab chars present, else comma.
      if (headerLine.indexOf('\t') !== -1) return '\t';
      return ',';
    }

    function csvEscape(s) {
      if (s === undefined || s === null) return '';
      s = String(s);
      if (s.includes('"')) s = s.replace(/"/g, '""');
      if (s.includes(',') || s.includes('\n') || s.includes('"')) return `"${s}"`;
      return s;
    }

    // Format a Date object as dd-mm-yy (e.g., 19-11-25)
    function formatDateToDDMMYYFromDate(d) {
      if (!(d instanceof Date) || isNaN(d.getTime())) return '';
      const dd = String(d.getDate()).padStart(2, '0');
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const yy = String(d.getFullYear() % 100).padStart(2, '0');
      return `${dd}-${mm}-${yy}`;
    }

    // Try to interpret various date representations and return dd-mm-yy or original trimmed string if unparseable.
    function formatActivityDate(raw) {
      if (raw === undefined || raw === null) return '';
      const s = String(raw).trim();
      if (s === '') return '';

      // Numeric Excel serial conversion (common when exporting from spreadsheets)
      if (/^\d+$/.test(s)) {
        const serial = parseInt(s, 10);
        // sanity check for reasonable Excel serials (e.g., >30 and <60000)
        if (serial > 30 && serial < 60000) {
          // Excel epoch: 1899-12-31 with the 1900 leap year bug (dates >= 60 are offset by 1)
          const epoch = Date.UTC(1899, 11, 31);
          const offset = serial > 59 ? -1 : 0;
          const ms = epoch + (serial + offset) * 24 * 60 * 60 * 1000;
          const d = new Date(ms);
          const formatted = formatDateToDDMMYYFromDate(d);
          if (formatted) return formatted;
        }
      }

      // Try native Date parsing (ISO and many common formats)
      const parsed = Date.parse(s);
      if (!isNaN(parsed)) {
        return formatDateToDDMMYYFromDate(new Date(parsed));
      }

      // Try common dd/mm/yyyy or dd-mm-yyyy or mm/dd/yyyy patterns and disambiguate heuristically.
      const m = s.match(/^(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})$/);
      if (m) {
        let p1 = parseInt(m[1], 10), p2 = parseInt(m[2], 10), p3 = parseInt(m[3], 10);
        let day, month, year;
        if (p3 > 31) { // likely year at end
          year = p3;
          // If one of p1/p2 > 12 we can determine which is day
          if (p1 > 12) { day = p1; month = p2; }
          else if (p2 > 12) { day = p2; month = p1; }
          else {
            // default to dd/mm/yyyy
            day = p1; month = p2;
          }
        } else {
          // two-digit year -> assume 2000+
          year = 2000 + p3;
          day = p1; month = p2;
        }
        const d = new Date(year, month - 1, day);
        if (!isNaN(d.getTime())) return formatDateToDDMMYYFromDate(d);
      }

      // fallback: return original trimmed value (so user can inspect unmodified if parsing failed)
      return s;
    }

    function processText(text) {
      if (!text) return '';

      // trim leading BOM, we'll leave it to header handling too
      if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);

      // Determine delimiter by examining the first non-empty line
      const firstNL = text.indexOf('\n');
      const firstLine = firstNL === -1 ? text : text.slice(0, firstNL);
      const delimiter = detectDelimiter(firstLine);

      const rows = parseDelimitedText(text, delimiter);

      // find first non-empty header row
      let headerRowIndex = 0;
      while (headerRowIndex < rows.length && rows[headerRowIndex].join('').trim() === '') headerRowIndex++;
      if (headerRowIndex >= rows.length) throw new Error('No header row found.');

      let headers = rows[headerRowIndex].map(h => (h || '').trim());
      // strip BOM if present in first header
      if (headers.length > 0 && headers[0].charCodeAt(0) === 0xFEFF) {
        headers[0] = headers[0].slice(1);
      }

      const idxOf = name => {
        let i = headers.indexOf(name);
        if (i !== -1) return i;
        const lower = name.toLowerCase();
        return headers.findIndex(h => (h || '').toLowerCase() === lower);
      };

      const required = [
        "Attendance",
        "ActivityDateDisplay",
        "ActivityDisplay",
        "FullName",
        "Age",
        "PostalCode1",
        "Gender",
        "RegistrationDocumentNumber"
      ];

      const indices = {};
      const missing = [];
      required.forEach(r => {
        const i = idxOf(r);
        if (i === -1) missing.push(r);
        indices[r] = i;
      });

      if (missing.length) {
        throw new Error('Missing required header(s): ' + missing.join(', '));
      }

      const outputLines = [
        "ActivityDateDisplay,ActivityDisplay,FullName,Age,PostalCode1,Gender,RegistrationDocumentNumber"
      ];

      for (let r = headerRowIndex + 1; r < rows.length; r++) {
        const row = rows[r];
        // skip empty rows
        if (!row || row.join('').trim() === '') continue;

        // pad row to headers length
        while (row.length < headers.length) row.push('');

        const attendanceVal = (row[indices["Attendance"]] || '').toString().trim();
        if (attendanceVal === '1') {
          // ActivityDisplay may contain newlines; we want only first visible line as before
          const rawADisp = row[indices["ActivityDisplay"]] || '';
          const adisp = (rawADisp.split(/\r|\n/)[0] || '').trim();

          // Format ActivityDateDisplay as dd-mm-yy
          const rawDate = row[indices["ActivityDateDisplay"]] || '';
          const formattedDate = formatActivityDate(rawDate);

          const outRow = [
            formattedDate,
            adisp,
            row[indices["FullName"]],
            row[indices["Age"]],
            row[indices["PostalCode1"]],
            row[indices["Gender"]],
            row[indices["RegistrationDocumentNumber"]]
          ].map(csvEscape).join(',');
          outputLines.push(outRow);
        }
      }

      return outputLines.join("\n");
    }

    function downloadCsv() {
      const blob = new Blob([processedCsv], {type: "text/csv;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = "AACFilteredAttendance.csv";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
